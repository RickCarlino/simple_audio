// Generated by CoffeeScript 1.6.3
(function() {
  var Recorder;

  Recorder = (function() {
    function Recorder() {
      if (!navigator.getUserMedia) {
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      }
      this.recording = false;
      this.leftchannel = [];
      this.rightchannel = [];
      this.recordingLength = 0;
      this.sampleRate = 44100;
      if (navigator.getUserMedia) {
        navigator.getUserMedia({
          audio: true
        }, this.sample, this.failure);
      } else {
        alert("Your browser doesn't support WebAudio or WebRTC. Upgrade to the latest Chrome or Firefox.");
      }
    }

    Recorder.prototype.sample = function(current_stream) {
      var AudioCtx, audioInput, bufferSize, context, recorder, volume;
      AudioCtx = window.AudioContext || window.webkitAudioContext;
      context = new AudioCtx();
      volume = context.createGain();
      audioInput = context.createMediaStreamSource(current_stream);
      audioInput.connect(volume);
      /* From the spec: This value controls how frequently the audioprocess event is 
          dispatched and how many sample-frames need to be processed each call. 
          Lower values for buffer size will result in a lower (better) latency. 
          Higher values will be necessary to avoid audio breakup and glitches
      */

      bufferSize = 2048;
      recorder = context.createJavaScriptNode(bufferSize, 2, 2);
      console.log('above');
      recorder.onaudioprocess = function(current_stream) {
        var left, right;
        if (!window.__recording) {
          return;
        }
        left = current_stream.inputBuffer.getChannelData(0);
        right = current_stream.inputBuffer.getChannelData(1);
        this.leftchannel.push(new Float32Array(left));
        this.rightchannel.push(new Float32Array(right));
        return this.recordingLength += bufferSize;
      };
      console.log('below');
      volume.connect(recorder);
      recorder.connect(context.destination);
      return window.a.start();
    };

    Recorder.prototype.start = function() {
      window.__recording = true;
      this.leftchannel.length = this.rightchannel.length = 0;
      this.recordingLength = 0;
      return console.log("Recording now...");
    };

    Recorder.prototype.stop = function() {
      var buffer, i, index, interleaved, leftBuffer, lng, rightBuffer, view, volume;
      window.__recording = false;
      leftBuffer = this._mergeBuffers(this.leftchannel, this.recordingLength);
      rightBuffer = this._mergeBuffers(this.rightchannel, this.recordingLength);
      interleaved = this._interleave(leftBuffer, rightBuffer);
      buffer = new ArrayBuffer(44 + interleaved.length * 2);
      view = new DataView(buffer);
      console.log('A');
      console.log(buffer.byteLength);
      console.log(view.byteLength);
      this._writeUTFBytes(view, 0, "RIFF");
      view.setUint32(4, 44 + interleaved.length * 2, true);
      this._writeUTFBytes(view, 8, "WAVE");
      console.log('B');
      console.log(buffer.byteLength);
      console.log(view.byteLength);
      this._writeUTFBytes(view, 12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      console.log('C');
      console.log(buffer.byteLength);
      console.log(view.byteLength);
      view.setUint16(22, 2, true);
      view.setUint32(24, this.sampleRate, true);
      view.setUint32(28, this.sampleRate * 4, true);
      view.setUint16(32, 4, true);
      view.setUint16(34, 16, true);
      this._writeUTFBytes(view, 36, "data");
      view.setUint32(40, interleaved.length * 2, true);
      lng = interleaved.length;
      index = 44;
      volume = 1;
      i = 0;
      while (i < lng) {
        view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
        index += 2;
        i++;
      }
      this.blob = new Blob([view], {
        type: "audio/wav"
      });
      return this.url = (window.URL || window.webkitURL).createObjectURL(this.blob);
    };

    Recorder.prototype._interleave = function(leftChannel, rightChannel) {
      var index, inputIndex, length, result;
      length = leftChannel.length + rightChannel.length;
      result = new Float32Array(length);
      inputIndex = 0;
      index = 0;
      while (index < length) {
        result[index++] = leftChannel[inputIndex];
        result[index++] = rightChannel[inputIndex];
        inputIndex++;
      }
      return result;
    };

    Recorder.prototype._mergeBuffers = function(channelBuffer, recordingLength) {
      var buffer, i, lng, offset, result;
      result = new Float32Array(recordingLength);
      offset = 0;
      lng = channelBuffer.length;
      i = 0;
      while (i < lng) {
        buffer = channelBuffer[i];
        result.set(buffer, offset);
        offset += buffer.length;
        i++;
      }
      return result;
    };

    Recorder.prototype._writeUTFBytes = function(view, offset, string) {
      var i, lng, _results;
      lng = string.length;
      i = 0;
      _results = [];
      while (i < lng) {
        view.setUint8(offset + i, string.charCodeAt(i));
        _results.push(i++);
      }
      return _results;
    };

    return Recorder;

  })();

  $(function() {
    return window.a = new Recorder();
  });

}).call(this);

/*
//@ sourceMappingURL=sandbox3.map
*/
